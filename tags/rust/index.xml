<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust on</title><link>https://www.ryken.cloud/tags/rust/</link><description>Recent content in rust on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 15 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.ryken.cloud/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>1. 所有权</title><link>https://www.ryken.cloud/1.-%E6%89%80%E6%9C%89%E6%9D%83/</link><pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1.-%E6%89%80%E6%9C%89%E6%9D%83/</guid><description>所有权 所有运行的程序都必须管理其使用计算机内存的方式。
一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存； 一些语言中，程序员必须亲自分配和释放内存。 Rust 则选择通过所有权系统管理内存（编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序） 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。所有权的存在就是为了管理堆数据。
所有权让 rust 无需垃圾回收即可保障内存安全。
所有权规则
Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 值有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 Rust 内存回收策略：内存在拥有它的变量离开作用域后就被自动释放。当变量离开作用域，Rust 为我们调用一个特殊的 drop函数，释放内存。</description></item><item><title>2. 引用与借用</title><link>https://www.ryken.cloud/2.-%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/</link><pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/2.-%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/</guid><description>不可变引用 calculate_length 函数，它以一个对象的引用作为参数而不是获取值的所有权
1 2 3 4 5 6 7 8 9 fn main(){lets1=String::from(&amp;#34;hello&amp;#34;);letlen=calculate_length(&amp;amp;s1);println!(&amp;#34;The length of &amp;#39;{}&amp;#39; is {}.&amp;#34;,s1,len);}fn calculate_length(s: &amp;amp;String)-&amp;gt; usize {s.</description></item><item><title>3. slice 类型</title><link>https://www.ryken.cloud/3.-slice-%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.-slice-%E7%B1%BB%E5%9E%8B/</guid><description>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 没有所有权
引出问题 题目：编写一个函数，该函数接收一个字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。
将 string 转换为字节数组，返回字节索引值 1 2 3 4 5 6 7 8 9 10 fn first_word(s: &amp;amp;String)-&amp;gt; usize {letbytes=s.</description></item><item><title>1. vector + map</title><link>https://www.ryken.cloud/1.-vector-+-map/</link><pubDate>Fri, 24 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1.-vector-+-map/</guid><description>Vector 字符串 Map</description></item><item><title>2. use 引入作用域</title><link>https://www.ryken.cloud/2.-use-%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F/</link><pubDate>Tue, 21 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/2.-use-%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid><description>使用 use 将路径引入作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 mod front_of_house{pubmod hosting{pubfn add_to_waitlist(){}}}usefront_of_house::hosting;pubfn eat_at_restaurant(){hosting::add_to_waitlist();hosting::add_to_waitlist();hosting::add_to_waitlist();} 1 2 3 4 5 6 usestd::collections::HashMap;fn main(){letmutmap=HashMap::new();map.</description></item><item><title>1. 包+crate</title><link>https://www.ryken.cloud/1.-%E5%8C%85+crate/</link><pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1.-%E5%8C%85+crate/</guid><description>包 + Crate 包：提供一系列功能的一个或者多个 crate。一个包中会包含有一个 Cargo.toml 文件，用于阐述如何构建这些 crate。
crate：一个二进制项或者库。crate root 是一个源文件，Rust 编译器以它为起始点，并构成crate 的根模块
包和 crate 关系：
包中至多只能包含一个库 crate 包中可以包含任意多个二进制 crate。 包中至少包含一个 crate，无论是库的还是二进制的 1 2 3 4 5 6 7 ~#: cargo new hello_world ~#: tree hello_world/ hello_world/ ├── Cargo.</description></item><item><title>3. 拆分模块到不同文件中</title><link>https://www.ryken.cloud/3.-%E6%8B%86%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B0%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E4%B8%AD/</link><pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.-%E6%8B%86%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B0%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E4%B8%AD/</guid><description>初文件： src/lib.rs
1 2 3 4 5 6 7 8 9 10 11 12 mod front_of_house{mod hosting{fn add_to_waitlist(){}fn seat_at_table(){}}mod serving{fn take_order(){}fn server_order(){}fn take_payment(){}}} 第一步拆分：src/lib.</description></item><item><title>3. 函数</title><link>https://www.ryken.cloud/3.-%E5%87%BD%E6%95%B0/</link><pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.-%E5%87%BD%E6%95%B0/</guid><description>在函数签名中，必须 声明每个参数的类型。返回值要在箭头（-&amp;gt;）后声明它的类型 使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。
表达式：表达式会计算出一些值，表达式可以是语句的一部分。函数调用是一个表达式。宏调用是一个表达式。 语句：语句并不返回值。 1 2 3 4 5 6 7 8 9 10 11 12 fn main(){letx=plus_one(5);println!</description></item><item><title>1. helloworld</title><link>https://www.ryken.cloud/1.-helloworld/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1.-helloworld/</guid><description>HelloWorld 1 2 3 fn main(){println!(&amp;#34;Hello, world!&amp;#34;);} rust 是预编译静态类型语言，将编译和运行分为两个独立的步骤； rustc 编译源文件 rustfmt 的自动格式化代码工具 println! 调用了 Rust 宏；符号 !</description></item><item><title>1. 变量与可变性</title><link>https://www.ryken.cloud/1.-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1.-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/</guid><description>变量、基本类型、函数、注释和控制流
Rust 变量 Rust 变量不可变性的原因及方法，何时不使用不可变性
变量不可变的原因 在尝试改变预设为不可变的值时，产生编译时错误是很重要的，因为这种情况可能导致 bug。如果一部分代码假设一个值永远也不会改变，而另一部分代码改变了这个值，第一部分代码就有可能以不可预料的方式运行。不得不承认这种 bug 的起因难以跟踪，尤其是第二部分代码只是 有时 会改变值。
Rust 编译器保证，如果声明一个值不会变，它就真的不会变。这意味着当阅读和编写代码时，不需要追踪一个值如何和在哪可能会被改变，从而使得代码易于推导。
变量可变与不可变 变量默认是不可改变的，当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。 但是仍然可以使用可变变量，变量名之前加 mut 来使其可变。除了允许改变值之外，mut 向读者表明了其他代码将会改变这个变量值的意图。 何时不使用不可变性 很多地方需要权衡取舍。 如使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快。对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的。</description></item><item><title>2. 数据类型</title><link>https://www.ryken.cloud/2.-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/2.-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>Rust 是 静态类型（statically typed）语言，即在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，必须增加类型注解。
1 letguess: u32 =&amp;#34;42&amp;#34;.parse().expect(&amp;#34;Not a number!&amp;#34;); 两类数据类型子集：标量（scalar）和复合（compound）
标量类型 整型 浮点型 布尔型 字符类型 整型 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。isize 或 usize 主要作为某些集合的索引。 Rust 数字类型默认是 i32：它通常是最快的，甚至在 64 位系统上也是。 整数溢出：</description></item><item><title>2. 猜数游戏</title><link>https://www.ryken.cloud/2.-%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/2.-%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</guid><description>读取标准输入的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 usestd::io;/* 默认情况下，Rust 将 prelude 模块中少量的类型引入到每个程序的作用域中。 如果需要的类型不在 prelude 中，你必须使用 use 语句显式地将其引入作用域 */fn main(){letmutguess=String::new();/* 1.</description></item><item><title>rust 编码规范</title><link>https://www.ryken.cloud/rust-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/rust-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid><description>常量的命名规范：使用下划线分隔的大写字母单词，并且可以在数字字面值中插入下划线来提升可读性。
1 2 3 fn main(){constMAX_POINTS: u32 =100_000;} Rust 代码中的函数和变量名使用 snake case 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。</description></item></channel></rss>