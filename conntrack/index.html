<!doctype html><html lang=en><head><script async defer data-website-id=08a754c4-6690-46d7-bb80-8ff93cfa232f src=https://umami.oldwinter.top/umami.js></script><meta charset=utf-8><meta name=description content="查看、加载、卸载 nf_conntrack 模块
连接跟踪（conntrack）：原理、应用及 Linux 内核实现 摘要 本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。
代码分析基于内核 4.19。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。
水平有限，文中不免有错误之处，欢迎指正交流。
1 引言 连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。"><title>Knowledge Garden</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://www.ryken.cloud//icon.png><link href=https://www.ryken.cloud/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://www.ryken.cloud/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://www.ryken.cloud/js/darkmode.66c3ed4615b59e04fa897375e67b0fe2.min.js></script>
<script src=https://www.ryken.cloud/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://www.ryken.cloud/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://www.ryken.cloud/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://www.ryken.cloud/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://www.ryken.cloud/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://www.ryken.cloud/",fetchData=Promise.all([fetch("https://www.ryken.cloud/indices/linkIndex.c83b530c16d6d7da0b36ea1cd7188b9b.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://www.ryken.cloud/indices/contentIndex.06f0c31ed297219dfd668386d31aa41a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://www.ryken.cloud",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://www.ryken.cloud",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-11MD77L81V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-11MD77L81V",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=search placeholder=支持标题及全文搜索...><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://www.ryken.cloud/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://www.ryken.cloud/>Knowledge Garden</a></h1><div class=spacer></div><div id=search-icon><p>search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>最近编辑于
Oct 29, 2024</p><ul class=tags></ul><aside class=mainTOC><details><summary>目录</summary><nav id=TableOfContents><ol><li><a href=#摘要>摘要</a></li></ol><ol><li><a href=#11-概念>1.1 概念</a></li><li><a href=#12-原理>1.2 原理</a></li><li><a href=#13-设计netfilter>1.3 设计：Netfilter</a></li><li><a href=#14-设计进一步思考>1.4 设计：进一步思考</a></li><li><a href=#15-应用>1.5 应用</a><ol><li><a href=#151-网络地址转换nat>1.5.1 网络地址转换（NAT）</a></li><li><a href=#152-有状态防火墙>1.5.2 有状态防火墙</a></li></ol></li><li><a href=#16-小结>1.6 小结</a></li></ol><ol><li><a href=#21-netfilter-框架>2.1 Netfilter 框架</a><ol><li><a href=#5-个-hook-点>5 个 hook 点</a></li><li><a href=#hook-返回值类型>hook 返回值类型</a></li><li><a href=#hook-优先级>hook 优先级</a></li></ol></li><li><a href=#22-过滤规则的组织>2.2 过滤规则的组织</a></li></ol><ol><li><a href=#31-重要结构体和函数>3.1 重要结构体和函数</a></li><li><a href=#32struct-nf_conntrack_tuple-元组tuple>3.2 <code>struct nf_conntrack_tuple {}</code>：元组（Tuple）</a><ol><li><a href=#结构体定义>结构体定义</a></li><li><a href=#ct-支持的协议>CT 支持的协议</a></li></ol></li><li><a href=#33struct-nf_conntrack_l4proto-协议需要实现的方法集合>3.3 <code>struct nf_conntrack_l4proto {}</code>：协议需要实现的方法集合</a></li><li><a href=#34struct-nf_conntrack_tuple_hash-哈希表项>3.4 <code>struct nf_conntrack_tuple_hash {}</code>：哈希表项</a></li><li><a href=#35struct-nf_conn-连接connection>3.5 <code>struct nf_conn {}</code>：连接（connection）</a></li><li><a href=#36nf_conntrack_in进入连接跟踪>3.6 <code>nf_conntrack_in()</code>：进入连接跟踪</a></li><li><a href=#37init_conntrack创建新连接记录>3.7 <code>init_conntrack()</code>：创建新连接记录</a></li><li><a href=#38nf_conntrack_confirm确认包没有被丢弃>3.8 <code>nf_conntrack_confirm()</code>：确认包没有被丢弃</a></li></ol><ol><li><a href=#41-重要数据结构和函数>4.1 重要数据结构和函数</a></li><li><a href=#42-nat-模块初始化>4.2 NAT 模块初始化</a></li><li><a href=#43struct-nf_nat_l3proto-协议相关的-nat-方法集>4.3 <code>struct nf_nat_l3proto {}</code>：协议相关的 NAT 方法集</a></li><li><a href=#44struct-nf_nat_l4proto-协议相关的-nat-方法集>4.4 <code>struct nf_nat_l4proto {}</code>：协议相关的 NAT 方法集</a></li><li><a href=#45nf_nat_inet_fn进入-nat>4.5 <code>nf_nat_inet_fn()</code>：进入 NAT</a><ol><li><a href=#masquerade>Masquerade</a></li></ol></li><li><a href=#46nf_nat_packet执行-nat>4.6 <code>nf_nat_packet()</code>：执行 NAT</a></li></ol><ol><li><a href=#51-查看加载卸载-nf_conntrack-模块>5.1 查看/加载/卸载 nf_conntrack 模块</a></li><li><a href=#52-sysctl-配置项>5.2 sysctl 配置项</a></li><li><a href=#53-监控>5.3 监控</a><ol><li><a href=#丢包监控>丢包监控</a></li><li><a href=#conntrack-table-使用量监控>conntrack table 使用量监控</a></li></ol></li></ol><ol><li><a href=#61-连接太多导致-conntrack-table-被打爆>6.1 连接太多导致 conntrack table 被打爆</a><ol><li><a href=#现象>现象</a></li><li><a href=#确认-conntrack-table-被打爆>确认 conntrack table 被打爆</a></li><li><a href=#解决方式>解决方式</a></li></ol></li></ol><ol><li><a href=#81-第一个-syn-包的重传间隔计算linux-419118-实现>8.1 第一个 SYN 包的重传间隔计算（Linux 4.19.118 实现）</a></li><li><a href=#82-根据-nf_conntrack_max-计算-conntrack-模块所需的内存>8.2 根据 nf_conntrack_max 计算 conntrack 模块所需的内存</a></li></ol></nav></details></aside><p>查看、加载、卸载 nf_conntrack 模块</p><a href=#连接跟踪conntrack原理应用及-linux-内核实现><h1 id=连接跟踪conntrack原理应用及-linux-内核实现><span class=hanchor arialabel=Anchor># </span>连接跟踪（conntrack）：原理、应用及 Linux 内核实现</h1></a><a href=#摘要><h2 id=摘要><span class=hanchor arialabel=Anchor># </span>摘要</h2></a><p>本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。</p><p>代码分析基于内核 <code>4.19</code>。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。</p><p>水平有限，文中不免有错误之处，欢迎指正交流。</p><a href=#1-引言><h1 id=1-引言><span class=hanchor arialabel=Anchor># </span>1 引言</h1></a><p>连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。</p><a href=#11-概念><h2 id=11-概念><span class=hanchor arialabel=Anchor># </span>1.1 概念</h2></a><p>连接跟踪，顾名思义，就是<strong>跟踪（并记录）连接的状态</strong>。
<img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668674793.png width=auto alt=upgit_20221117_1668674793.png></p><center>Fig 1.1. 连接跟踪及其内核位置示意图</center><p>例如，上图是一台 IP 地址为 <code>10.1.1.2</code> 的 Linux 机器，我们能看到这台机器上有三条 连接：</p><ol><li>机器访问外部 HTTP 服务的连接（目的端口 80）</li><li>外部访问机器内 FTP 服务的连接（目的端口 21）</li><li>机器访问外部 DNS 服务的连接（目的端口 53）</li></ol><p>连接跟踪所做的事情就是发现并跟踪这些连接的状态，具体包括：</p><ul><li>从数据包中提取<strong>元组</strong>（tuple）信息，辨别<strong>数据流</strong>（flow）和对应的<strong>连接</strong>（connection）</li><li>为所有连接维护一个<strong>状态数据库</strong>（conntrack table），例如连接的创建时间、发送 包数、发送字节数等等</li><li>回收过期的连接（GC）</li><li>为更上层的功能（例如 NAT）提供服务</li></ul><p>需要注意的是，<strong>连接跟踪中所说的“连接”，概念和 TCP/IP 协议中“面向连接”（ connection oriented）的“连接”并不完全相同</strong>，简单来说：</p><ul><li>TCP/IP 协议中，连接是一个四层（Layer 4）的概念。<ul><li>TCP 是有连接的，或称面向连接的（connection oriented），发送出去的包都要求对端应答（ACK），并且有重传机制</li><li>UDP 是无连接的，发送的包无需对端应答，也没有重传机制</li></ul></li><li>CT 中，一个元组（tuple）定义的一条数据流（flow ）就表示一条连接（connection）。<ul><li>后面会看到 UDP 甚至是 <strong>ICMP 这种三层协议在 CT 中也都是有连接记录的</strong></li><li>但<strong>不是所有协议都会被连接跟踪</strong></li></ul></li></ul><p>本文中用到“连接”一词时，大部分情况下指的都是后者，即“连接跟踪”中的“连接”。</p><a href=#12-原理><h2 id=12-原理><span class=hanchor arialabel=Anchor># </span>1.2 原理</h2></a><p>了解以上概念之后，我们来思考下连接跟踪的技术原理。</p><p>要跟踪一台机器的所有连接状态，就需要</p><ol><li><strong>拦截（或称过滤）流经这台机器的每一个数据包，并进行分析</strong>。</li><li>根据这些信息<strong>建立</strong>起这台机器上的<strong>连接信息数据库</strong>（conntrack table）。</li><li>根据拦截到的包信息，不断更新数据库</li></ol><p>例如，</p><ol><li>拦截到一个 TCP <code>SYNC</code> 包时，说明正在尝试建立 TCP 连接，需要创建一条新 conntrack entry 来记录这条连接</li><li>拦截到一个属于已有 conntrack entry 的包时，需要更新这条 conntrack entry 的收发包数等统计信息</li></ol><p>除了以上两点功能需求，还要考虑<strong>性能问题</strong>，因为连接跟踪要对每个包进行过滤和分析 。性能问题非常重要，但不是本文重点，后面介绍实现时会进一步提及。</p><p>之外，这些功能最好还有配套的管理工具来更方便地使用。</p><a href=#13-设计netfilter><h2 id=13-设计netfilter><span class=hanchor arialabel=Anchor># </span>1.3 设计：Netfilter</h2></a><p><strong>Linux 的连接跟踪是在 
<a href=https://en.wikipedia.org/wiki/Netfilter rel=noopener>Netfilter</a> 中实现的。</strong>
<img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668674893.png width=auto alt=upgit_20221117_1668674893.png></p><center>Fig 1.2. Netfilter architecture inside Linux kernel</center><p>Netfilter 是 Linux 内核中一个对数据 包进行<strong>控制、修改和过滤</strong>（manipulation and filtering）的框架。它在内核协议 栈中设置了若干hook 点，以此对数据包进行拦截、过滤或其他处理。</p><blockquote><p>说地更直白一些，hook 机制就是在数据包的必经之路上设置若干检测点，所有到达这 些检测点的包都必须接受检测，根据检测的结果决定：</p><ol><li>放行：不对包进行任何修改，退出检测逻辑，继续后面正常的包处理</li><li>修改：例如修改 IP 地址进行 NAT，然后将包放回正常的包处理逻辑</li><li>丢弃：安全策略或防火墙功能</li></ol><p>连接跟踪模块只是完成连接信息的采集和录入功能，并不会修改或丢弃数据包，后者是其 他模块（例如 NAT）基于 Netfilter hook 完成的。</p></blockquote><p>Netfilter 是最古老的内核框架之一，1998 年开始开发，2000 年合并到 <code>2.4.x</code> 内 核主线版本 [5]。</p><a href=#14-设计进一步思考><h2 id=14-设计进一步思考><span class=hanchor arialabel=Anchor># </span>1.4 设计：进一步思考</h2></a><p>现在提到连接跟踪（conntrack），可能首先都会想到 Netfilter。但由上节讨论可知， 连接跟踪概念是独立于 Netfilter 的，<strong>Netfilter 只是 Linux 内核中的一种连接跟踪实现</strong>。</p><p>换句话说，<strong>只要具备了 hook 能力，能拦截到进出主机的每个包，完全可以在此基础上自 己实现一套连接跟踪</strong>。
<img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668674950.png width=auto alt=upgit_20221117_1668674950.png></p><center>Fig 1.3. Cilium's conntrack and NAT architectrue</center><p>云原生网络方案 Cilium 在 <code>1.7.4+</code> 版本就实现了这样一套独立的连接跟踪和 NAT 机制 （完备功能需要 Kernel <code>4.19+</code>）。其基本原理是：</p><ol><li>基于 BPF hook 实现数据包的拦截功能（等价于 netfilter 里面的 hook 机制）</li><li>在 BPF hook 的基础上，实现一套全新的 conntrack 和 NAT</li></ol><p>因此，即便
<a href=https://github.com/cilium/cilium/issues/12879 rel=noopener>卸载 Netfilter</a> ，也不会影响 Cilium 对 Kubernetes ClusterIP、NodePort、ExternalIPs 和 LoadBalancer 等功能的支持 [2]。</p><p>由于这套连接跟踪机制是独立于 Netfilter 的，因此它的 conntrack 和 NAT 信息也没有 存储在内核的（也就是 Netfilter 的）conntrack table 和 NAT table。所以常规的 <code>conntrack/netstats/ss/lsof</code> 等工具是看不到的，要使用 Cilium 的命令，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cilium bpf nat list
</span></span><span class=line><span class=cl>$ cilium bpf ct list global
</span></span></code></pre></td></tr></table></div></div><p>配置也是独立的，需要在 Cilium 里面配置，例如命令行选项 <code>--bpf-ct-tcp-max</code>。</p><p>另外，本文会多次提到连接跟踪模块和 NAT 模块独立，但<strong>出于性能考虑，具体实现中 二者代码可能是有耦合的</strong>。例如 Cilium 做 conntrack 的垃圾回收（GC）时就会顺便把 NAT 里相应的 entry 回收掉，而非为 NAT 做单独的 GC。</p><a href=#15-应用><h2 id=15-应用><span class=hanchor arialabel=Anchor># </span>1.5 应用</h2></a><p>来看几个 conntrack 的具体应用。</p><a href=#151-网络地址转换nat><h3 id=151-网络地址转换nat><span class=hanchor arialabel=Anchor># </span>1.5.1 网络地址转换（NAT）</h3></a><p>网络地址转换（NAT），名字表达的意思也比较清楚：对（数据包的）网络地址（<code>IP + Port</code>）进行转换。
<img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668674981.png width=auto alt=upgit_20221117_1668674981.png></p><p><cneter>Fig 1.4. NAT 及其内核位置示意图</cneter></p><p>例如上图中，机器自己的 IP <code>10.1.1.2</code> 是能与外部正常通信的，但 <code>192.168</code> 网段是私有 IP 段，外界无法访问，也就是说源 IP 地址是 <code>192.168</code> 的包，其<strong>应答包是无法回来的</strong>。因此，</p><ul><li>当源地址为 <code>192.168</code> 网段的包要出去时，机器会先将源 IP 换成机器自己的 <code>10.1.1.2</code> 再发送出去；</li><li>收到应答包时，再进行相反的转换。</li></ul><p>这就是 NAT 的基本过程。</p><p>Docker 默认的 <code>bridge</code> 网络模式就是这个原理 [4]。每个容器会分一个私有网段的 IP 地址，这个 IP 地址可以在宿主机内的不同容器之间通信，但容器流量出宿主机时要进行 NAT。</p><p>NAT 又可以细分为几类：</p><ul><li>SNAT：对源地址（source）进行转换</li><li>DNAT：对目的地址（destination）进行转换</li><li>Full NAT：同时对源地址和目的地址进行转换</li></ul><p>以上场景属于 SNAT，将不同私有 IP 都映射成同一个“公有 IP”，以使其能访问外部网络服 务。这种场景也属于正向代理。</p><p>NAT 依赖连接跟踪的结果。连接跟踪<strong>最重要的使用场景</strong>就是 NAT。</p><a href=#四层负载均衡l4lb><h4 id=四层负载均衡l4lb><span class=hanchor arialabel=Anchor># </span>四层负载均衡（L4LB）</h4></a><p>再将范围稍微延伸一点，讨论一下 NAT 模式的四层负载均衡。</p><p>四层负载均衡是根据包的四层信息（例如 <code>src/dst ip, src/dst port, proto</code>）做流量分发。</p><p>VIP（Virtual IP）是四层负载均衡的一种实现方式：</p><ul><li>多个后端真实 IP（Real IP）挂到同一个虚拟 IP（VIP）上</li><li>客户端过来的流量先到达 VIP，再经负载均衡算法转发给某个特定的后端 IP</li></ul><p>如果在 VIP 和 Real IP 节点之间使用的 NAT 技术（也可以使用其他技术），那客户端访 问服务端时，L4LB 节点将做双向 NAT（Full NAT），数据流如下图所示：
<img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668675014.png width=auto alt=upgit_20221117_1668675014.png></p><center>Fig 1.5. L4LB: Traffic path in NAT mode [3]</center>
<a href=#152-有状态防火墙><h3 id=152-有状态防火墙><span class=hanchor arialabel=Anchor># </span>1.5.2 有状态防火墙</h3></a><p>有状态防火墙（stateful firewall）是相对于早期的<strong>无状态防火墙</strong>（stateless firewall）而言的：早期防火墙只能写 <code>drop syn to port 443</code> 或者 <code>allow syn to port 80</code> 这种非常简单直接 的规则，<strong>没有 flow 的概念</strong>，因此无法实现诸如 <strong>“如果这个 ack 之前已经有 syn， 就 allow，否则 drop”</strong> 这样的规则，使用非常受限 [6]。</p><p>显然，要实现有状态防火墙，就必须记录 flow 和状态，这正是 conntrack 做的事情。</p><p>来看个更具体的防火墙应用：OpenStack 主机防火墙解决方案 —— 安全组（security group）。</p><a href=#openstack-安全组><h4 id=openstack-安全组><span class=hanchor arialabel=Anchor># </span>OpenStack 安全组</h4></a><p>简单来说，安全组实现了<strong>虚拟机级别</strong>的安全隔离，具体实现是：在 node 上连接 VM 的 网络设备上做有状态防火墙。在当时，最能实现这一功能的可能就是 Netfilter/iptables。</p><p>回到宿主机内网络拓扑问题： OpenStack 使用 OVS bridge 来连接一台宿主机内的所有 VM。 如果只从网络连通性考虑，那每个 VM 应该直接连到 OVS bridge <code>br-int</code>。但这里问题 就来了 [7]：</p><ul><li>（较早版本的）OVS 没有 conntrack 模块，</li><li>Linux 中有 conntrack 模块，但基于 conntrack 的防火墙<strong>工作在 IP 层</strong>（L3），通过 iptables 控制，</li><li>而 <strong>OVS 是 L2 模块</strong>，无法使用 L3 模块的功能，</li></ul><p>最终结果是：无法在 OVS （连接虚拟机）的设备上做防火墙。</p><p>所以，2016 之前 OpenStack 的解决方案是，在每个 OVS 和 VM 之间再加一个 Linux bridge ，如下图所示:
<img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668675060.png width=auto alt=upgit_20221117_1668675060.png></p><center>Fig 1.6. Network topology within an OpenStack compute node</cneter><p>Linux bridge 也是 L2 模块，按道理也无法使用 iptables。但是，<strong>它有一个 L2 工具 ebtables，能够跳转到 iptables</strong>，因此间接支持了 iptables，也就能用到 Netfilter/iptables 防火墙的功能。</p><p>这种暴力堆砌的方式不仅丑陋、增加网络复杂性，而且会导致性能问题。因此， RedHat 在 2016 年提出了一个 OVS conntrack 方案 [7]，从那以后，才有可能干掉 Linux bridge 而仍然具备安全组的功能。</p><a href=#16-小结><h2 id=16-小结><span class=hanchor arialabel=Anchor># </span>1.6 小结</h2></a><p>以上是理论篇，接下来看一下内核实现。</p><a href=#2-netfilter-hook-机制实现><h1 id=2-netfilter-hook-机制实现><span class=hanchor arialabel=Anchor># </span>2 Netfilter hook 机制实现</h1></a><p>Netfilter 由几个模块构成，其中最主要的是<strong>连接跟踪</strong>（CT）模块和<strong>网络地址转换</strong>（NAT）模块。</p><p>CT 模块的主要职责是识别出可进行连接跟踪的包。 CT 模块独立于 NAT 模块，但主要目的是服务于后者。</p><a href=#21-netfilter-框架><h2 id=21-netfilter-框架><span class=hanchor arialabel=Anchor># </span>2.1 Netfilter 框架</h2></a><a href=#5-个-hook-点><h3 id=5-个-hook-点><span class=hanchor arialabel=Anchor># </span>5 个 hook 点</h3></a><p><img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668675145.png width=auto alt=upgit_20221117_1668675145.png></p><center>图 2.1. The 5 hook points in netfilter framework</center><p>如上图所示，Netfilter 在内核协议栈的包处理路径上提供了 5 个 hook 点，分别是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/uapi/linux/netfilter_ipv4.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#define NF_IP_PRE_ROUTING    0 /* After promisc drops, checksum checks. */
</span></span><span class=line><span class=cl>#define NF_IP_LOCAL_IN       1 /* If the packet is destined for this box. */
</span></span><span class=line><span class=cl>#define NF_IP_FORWARD        2 /* If the packet is destined for another interface. */
</span></span><span class=line><span class=cl>#define NF_IP_LOCAL_OUT      3 /* Packets coming from a local process. */
</span></span><span class=line><span class=cl>#define NF_IP_POST_ROUTING   4 /* Packets about to hit the wire. */
</span></span><span class=line><span class=cl>#define NF_IP_NUMHOOKS       5
</span></span></code></pre></td></tr></table></div></div><p>用户可以在这些 hook 点注册自己的处理函数（handlers）。当有数据包经过 hook 点时， 就会调用相应的 handlers。</p><blockquote><p>另外还有一套 <code>NF_INET_</code> 开头的定义，<code>include/uapi/linux/netfilter.h</code>。 这两套是等价的，从注释看，<code>NF_IP_</code> 开头的定义可能是为了保持兼容性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>enum nf_inet_hooks {
</span></span><span class=line><span class=cl>    NF_INET_PRE_ROUTING,
</span></span><span class=line><span class=cl>    NF_INET_LOCAL_IN,
</span></span><span class=line><span class=cl>    NF_INET_FORWARD,
</span></span><span class=line><span class=cl>    NF_INET_LOCAL_OUT,
</span></span><span class=line><span class=cl>    NF_INET_POST_ROUTING,
</span></span><span class=line><span class=cl>    NF_INET_NUMHOOKS
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div></blockquote><a href=#hook-返回值类型><h3 id=hook-返回值类型><span class=hanchor arialabel=Anchor># </span>hook 返回值类型</h3></a><p>hook 函数对包进行判断或处理之后，需要返回一个判断结果，指导接下来要对这个包做什 么。可能的结果有：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/uapi/linux/netfilter.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#define NF_DROP   0  // 已丢弃这个包
</span></span><span class=line><span class=cl>#define NF_ACCEPT 1  // 接受这个包，结束判断，继续下一步处理
</span></span><span class=line><span class=cl>#define NF_STOLEN 2  // 临时 hold 这个包，不用再继续穿越协议栈了。常见的情形是缓存分片之后的包（等待重组）
</span></span><span class=line><span class=cl>#define NF_QUEUE  3  // 应当将包放到队列
</span></span><span class=line><span class=cl>#define NF_REPEAT 4  // 当前处理函数应当被再次调用
</span></span></code></pre></td></tr></table></div></div><a href=#hook-优先级><h3 id=hook-优先级><span class=hanchor arialabel=Anchor># </span>hook 优先级</h3></a><p>每个 hook 点可以注册多个处理函数（handler）。在注册时必须指定这些 handlers 的<strong>优先级</strong>，这样触发 hook 时能够根据优先级依次调用处理函数。</p><a href=#22-过滤规则的组织><h2 id=22-过滤规则的组织><span class=hanchor arialabel=Anchor># </span>2.2 过滤规则的组织</h2></a><p><code>iptables</code> 是配置 Netfilter 过滤功能的用户空间工具。为便于管理， 过滤规则按功能分为若干 table：</p><ul><li>raw</li><li>filter</li><li>nat</li><li>mangle</li></ul><p>这不是本文重点。更多信息可参考 
<a href=https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/ rel=noopener>(译) 深入理解 iptables 和 netfilter 架构</a></p><a href=#3-netfilter-conntrack-实现><h1 id=3-netfilter-conntrack-实现><span class=hanchor arialabel=Anchor># </span>3 Netfilter conntrack 实现</h1></a><p>连接跟踪模块用于维护<strong>可跟踪协议</strong>（trackable protocols）的连接状态。 也就是说，连接跟踪<strong>针对的是特定协议的包，而不是所有协议的包</strong>。 稍后会看到它支持哪些协议。</p><a href=#31-重要结构体和函数><h2 id=31-重要结构体和函数><span class=hanchor arialabel=Anchor># </span>3.1 重要结构体和函数</h2></a><p>重要结构体：</p><ul><li><code>struct nf_conntrack_tuple {}</code>: 定义一个 tuple。<ul><li><code>struct nf_conntrack_man {}</code>：tuple 的 manipulable part。<ul><li><code>struct nf_conntrack_man_proto {}</code>：manipulable part 中协议相关的部分。</li></ul></li></ul></li><li><code>struct nf_conntrack_l4proto {}</code>: 支持连接跟踪的<strong>协议需要实现的方法集</strong>（以及其他协议相关字段）。</li><li><code>struct nf_conntrack_tuple_hash {}</code>：哈希表（conntrack table）中的表项（entry）。</li><li><code>struct nf_conn {}</code>：<strong>定义一个 flow</strong>。</li></ul><p>重要函数：</p><ul><li><p><code>hash_conntrack_raw()</code>：根据 tuple 计算出一个 32 位的哈希值（hash key）。</p></li><li><p><code>nf_conntrack_in()</code>：<strong>连接跟踪模块的核心，包进入连接跟踪的地方</strong>。</p></li><li><p><code>resolve_normal_ct() -> init_conntrack() -> ct = __nf_conntrack_alloc(); l4proto->new(ct)</code></p><p>创建一个新的连接记录（conntrack entry），然后初始化。</p></li><li><p><code>nf_conntrack_confirm()</code>：确认前面通过 <code>nf_conntrack_in()</code> 创建的新连接（是否被丢弃）。</p></li></ul><a href=#32struct-nf_conntrack_tuple-元组tuple><h2 id=32struct-nf_conntrack_tuple-元组tuple><span class=hanchor arialabel=Anchor># </span>3.2 <code>struct nf_conntrack_tuple {}</code>：元组（Tuple）</h2></a><p>Tuple 是连接跟踪中最重要的概念之一。</p><p><strong>一个 tuple 定义一个单向（unidirectional）flow</strong>。内核代码中有如下注释：</p><blockquote><p>//include/net/netfilter/nf_conntrack_tuple.h</p><p>A <code>tuple</code> is a structure containing the information to uniquely identify a connection. ie. if two packets have the same tuple, they are in the same connection; if not, they are not.</p></blockquote><a href=#结构体定义><h3 id=结构体定义><span class=hanchor arialabel=Anchor># </span>结构体定义</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//include/net/netfilter/nf_conntrack_tuple.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 为方便 NAT 的实现，内核将 tuple 结构体拆分为 &#34;manipulatable&#34; 和 &#34;non-manipulatable&#34; 两部分
</span></span><span class=line><span class=cl>// 下面结构体中的 _man 是 manipulatable 的缩写
</span></span><span class=line><span class=cl>                                               // ude/uapi/linux/netfilter.h
</span></span><span class=line><span class=cl>                                               union nf_inet_addr {
</span></span><span class=line><span class=cl>                                                   __u32            all[4];
</span></span><span class=line><span class=cl>                                                   __be32           ip;
</span></span><span class=line><span class=cl>                                                   __be32           ip6[4];
</span></span><span class=line><span class=cl>                                                   struct in_addr   in;
</span></span><span class=line><span class=cl>                                                   struct in6_addr  in6;
</span></span><span class=line><span class=cl>/* manipulable part of the tuple */         /  };
</span></span><span class=line><span class=cl>struct nf_conntrack_man {                  /
</span></span><span class=line><span class=cl>    union nf_inet_addr           u3; --&gt;--/
</span></span><span class=line><span class=cl>    union nf_conntrack_man_proto u;  --&gt;--\
</span></span><span class=line><span class=cl>                                           \   // include/uapi/linux/netfilter/nf_conntrack_tuple_common.h
</span></span><span class=line><span class=cl>    u_int16_t l3num; // L3 proto            \  // 协议相关的部分
</span></span><span class=line><span class=cl>};                                            union nf_conntrack_man_proto {
</span></span><span class=line><span class=cl>                                                  __be16 all;/* Add other protocols here. */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                                  struct { __be16 port; } tcp;
</span></span><span class=line><span class=cl>                                                  struct { __be16 port; } udp;
</span></span><span class=line><span class=cl>                                                  struct { __be16 id;   } icmp;
</span></span><span class=line><span class=cl>                                                  struct { __be16 port; } dccp;
</span></span><span class=line><span class=cl>                                                  struct { __be16 port; } sctp;
</span></span><span class=line><span class=cl>                                                  struct { __be16 key;  } gre;
</span></span><span class=line><span class=cl>                                              };
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct nf_conntrack_tuple { /* This contains the information to distinguish a connection. */
</span></span><span class=line><span class=cl>    struct nf_conntrack_man src;  // 源地址信息，manipulable part
</span></span><span class=line><span class=cl>    struct {
</span></span><span class=line><span class=cl>        union nf_inet_addr u3;
</span></span><span class=line><span class=cl>        union {
</span></span><span class=line><span class=cl>            __be16 all; /* Add other protocols here. */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            struct { __be16 port;         } tcp;
</span></span><span class=line><span class=cl>            struct { __be16 port;         } udp;
</span></span><span class=line><span class=cl>            struct { u_int8_t type, code; } icmp;
</span></span><span class=line><span class=cl>            struct { __be16 port;         } dccp;
</span></span><span class=line><span class=cl>            struct { __be16 port;         } sctp;
</span></span><span class=line><span class=cl>            struct { __be16 key;          } gre;
</span></span><span class=line><span class=cl>        } u;
</span></span><span class=line><span class=cl>        u_int8_t protonum; /* The protocol. */
</span></span><span class=line><span class=cl>        u_int8_t dir;      /* The direction (for tuplehash) */
</span></span><span class=line><span class=cl>    } dst;                       // 目的地址信息
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p><strong>Tuple 结构体中只有两个字段 src 和 dst</strong>，分别保存源和目的信息。<code>src</code> 和 <code>dst</code> 自身也是结构体，能保存不同类型协议的数据。以 IPv4 UDP 为例，五元组分别保存在如下字段：</p><ul><li><code>dst.protonum</code>：协议类型</li><li><code>src.u3.ip</code>：源 IP 地址</li><li><code>dst.u3.ip</code>：目的 IP 地址</li><li><code>src.u.udp.port</code>：源端口号</li><li><code>dst.u.udp.port</code>：目的端口号</li></ul><a href=#ct-支持的协议><h3 id=ct-支持的协议><span class=hanchor arialabel=Anchor># </span>CT 支持的协议</h3></a><p>从以上定义可以看到，连接跟踪模块<strong>目前只支持以下六种协议</strong>：TCP、UDP、ICMP、DCCP、SCTP、GRE。</p><p><strong>注意其中的 ICMP 协议</strong>。大家可能会认为，连接跟踪模块依据包的三层和四层信息做 哈希，而 ICMP 是三层协议，没有四层信息，因此 ICMP 肯定不会被 CT 记录。但<strong>实际上 是会的</strong>，上面代码可以看到，ICMP 使用了其头信息中的 ICMP <code>type</code>和 <code>code</code> 字段来 定义 tuple。</p><a href=#33struct-nf_conntrack_l4proto-协议需要实现的方法集合><h2 id=33struct-nf_conntrack_l4proto-协议需要实现的方法集合><span class=hanchor arialabel=Anchor># </span>3.3 <code>struct nf_conntrack_l4proto {}</code>：协议需要实现的方法集合</h2></a><p>支持连接跟踪的协议都需要实现 <code>struct nf_conntrack_l4proto {}</code> 结构体 中定义的方法，例如 <code>pkt_to_tuple()</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/net/netfilter/nf_conntrack_l4proto.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct nf_conntrack_l4proto {
</span></span><span class=line><span class=cl>    u_int16_t l3proto; /* L3 Protocol number. */
</span></span><span class=line><span class=cl>    u_int8_t  l4proto; /* L4 Protocol number. */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 从包（skb）中提取 tuple
</span></span><span class=line><span class=cl>    bool (*pkt_to_tuple)(struct sk_buff *skb, ... struct nf_conntrack_tuple *tuple);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 对包进行判决，返回判决结果（returns verdict for packet）
</span></span><span class=line><span class=cl>    int (*packet)(struct nf_conn *ct, const struct sk_buff *skb ...);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 创建一个新连接。如果成功返回 TRUE；如果返回的是 TRUE，接下来会调用 packet() 方法
</span></span><span class=line><span class=cl>    bool (*new)(struct nf_conn *ct, const struct sk_buff *skb, unsigned int dataoff);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 判断当前数据包能否被连接跟踪。如果返回成功，接下来会调用 packet() 方法
</span></span><span class=line><span class=cl>    int (*error)(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb, ...);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><a href=#34struct-nf_conntrack_tuple_hash-哈希表项><h2 id=34struct-nf_conntrack_tuple_hash-哈希表项><span class=hanchor arialabel=Anchor># </span>3.4 <code>struct nf_conntrack_tuple_hash {}</code>：哈希表项</h2></a><p>conntrack 将活动连接的状态存储在一张哈希表中（<code>key: value</code>）。</p><p><code>hash_conntrack_raw()</code> 根据 tuple 计算出一个 32 位的哈希值（key）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_conntrack_core.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>static u32 hash_conntrack_raw(struct nf_conntrack_tuple *tuple, struct net *net)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    get_random_once(&amp;nf_conntrack_hash_rnd, sizeof(nf_conntrack_hash_rnd));
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* The direction must be ignored, so we hash everything up to the
</span></span><span class=line><span class=cl>     * destination ports (which is a multiple of 4) and treat the last three bytes manually.  */
</span></span><span class=line><span class=cl>    u32 seed = nf_conntrack_hash_rnd ^ net_hash_mix(net);
</span></span><span class=line><span class=cl>    unsigned int n = (sizeof(tuple-&gt;src) + sizeof(tuple-&gt;dst.u3)) / sizeof(u32);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return jhash2((u32 *)tuple, n, seed ^ ((tuple-&gt;dst.u.all &lt;&lt; 16) | tuple-&gt;dst.protonum));
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>注意其中是如何利用 tuple 的不同字段来计算哈希的。</p><p><code>nf_conntrack_tuple_hash</code> 是哈希表中的表项（value）:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/net/netfilter/nf_conntrack_tuple.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 每条连接在哈希表中都对应两项，分别对应两个方向（egress/ingress）
</span></span><span class=line><span class=cl>// Connections have two entries in the hash table: one for each way
</span></span><span class=line><span class=cl>struct nf_conntrack_tuple_hash {
</span></span><span class=line><span class=cl>    struct hlist_nulls_node   hnnode;   // 指向该哈希对应的连接 struct nf_conn，采用 list 形式是为了解决哈希冲突
</span></span><span class=line><span class=cl>    struct nf_conntrack_tuple tuple;    // N 元组，前面详细介绍过了
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><a href=#35struct-nf_conn-连接connection><h2 id=35struct-nf_conn-连接connection><span class=hanchor arialabel=Anchor># </span>3.5 <code>struct nf_conn {}</code>：连接（connection）</h2></a><p><strong>Netfilter 中每个 flow 都称为一个 connection</strong>，即使是对那些非面向连接的协议（例 如 UDP）。每个 connection 用 <code>struct nf_conn {}</code> 表示，主要字段如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/net/netfilter/nf_conntrack.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                                  // include/linux/skbuff.h
</span></span><span class=line><span class=cl>                                        ------&gt;   struct nf_conntrack {
</span></span><span class=line><span class=cl>                                        |             atomic_t use;  // 连接引用计数？
</span></span><span class=line><span class=cl>                                        |         };
</span></span><span class=line><span class=cl>struct nf_conn {                        |
</span></span><span class=line><span class=cl>    struct nf_conntrack            ct_general;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    struct nf_conntrack_tuple_hash tuplehash[IP_CT_DIR_MAX]; // 哈希表项，数组是因为要记录两个方向的 flow
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    unsigned long status; // 连接状态，见下文
</span></span><span class=line><span class=cl>    u32 timeout;          // 连接状态的定时器
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    possible_net_t ct_net;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    struct hlist_node    nat_bysource;
</span></span><span class=line><span class=cl>                                                        // per conntrack: protocol private data
</span></span><span class=line><span class=cl>    struct nf_conn *master;                             union nf_conntrack_proto {
</span></span><span class=line><span class=cl>                                                       /    /* insert conntrack proto private data here */
</span></span><span class=line><span class=cl>    u_int32_t mark;    /* 对 skb 进行特殊标记 */      /     struct nf_ct_dccp dccp;
</span></span><span class=line><span class=cl>    u_int32_t secmark;                               /      struct ip_ct_sctp sctp;
</span></span><span class=line><span class=cl>                                                    /       struct ip_ct_tcp tcp;
</span></span><span class=line><span class=cl>    union nf_conntrack_proto proto; ----------&gt;----/        struct nf_ct_gre gre;
</span></span><span class=line><span class=cl>};                                                          unsigned int tmpl_padto;
</span></span><span class=line><span class=cl>                                                        };
</span></span></code></pre></td></tr></table></div></div><p><strong>连接的状态集合 enum ip_conntrack_status</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/uapi/linux/netfilter/nf_conntrack_common.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>enum ip_conntrack_status {
</span></span><span class=line><span class=cl>    IPS_EXPECTED      = (1 &lt;&lt; IPS_EXPECTED_BIT),
</span></span><span class=line><span class=cl>    IPS_SEEN_REPLY    = (1 &lt;&lt; IPS_SEEN_REPLY_BIT),
</span></span><span class=line><span class=cl>    IPS_ASSURED       = (1 &lt;&lt; IPS_ASSURED_BIT),
</span></span><span class=line><span class=cl>    IPS_CONFIRMED     = (1 &lt;&lt; IPS_CONFIRMED_BIT),
</span></span><span class=line><span class=cl>    IPS_SRC_NAT       = (1 &lt;&lt; IPS_SRC_NAT_BIT),
</span></span><span class=line><span class=cl>    IPS_DST_NAT       = (1 &lt;&lt; IPS_DST_NAT_BIT),
</span></span><span class=line><span class=cl>    IPS_NAT_MASK      = (IPS_DST_NAT | IPS_SRC_NAT),
</span></span><span class=line><span class=cl>    IPS_SEQ_ADJUST    = (1 &lt;&lt; IPS_SEQ_ADJUST_BIT),
</span></span><span class=line><span class=cl>    IPS_SRC_NAT_DONE  = (1 &lt;&lt; IPS_SRC_NAT_DONE_BIT),
</span></span><span class=line><span class=cl>    IPS_DST_NAT_DONE  = (1 &lt;&lt; IPS_DST_NAT_DONE_BIT),
</span></span><span class=line><span class=cl>    IPS_NAT_DONE_MASK = (IPS_DST_NAT_DONE | IPS_SRC_NAT_DONE),
</span></span><span class=line><span class=cl>    IPS_DYING         = (1 &lt;&lt; IPS_DYING_BIT),
</span></span><span class=line><span class=cl>    IPS_FIXED_TIMEOUT = (1 &lt;&lt; IPS_FIXED_TIMEOUT_BIT),
</span></span><span class=line><span class=cl>    IPS_TEMPLATE      = (1 &lt;&lt; IPS_TEMPLATE_BIT),
</span></span><span class=line><span class=cl>    IPS_UNTRACKED     = (1 &lt;&lt; IPS_UNTRACKED_BIT),
</span></span><span class=line><span class=cl>    IPS_HELPER        = (1 &lt;&lt; IPS_HELPER_BIT),
</span></span><span class=line><span class=cl>    IPS_OFFLOAD       = (1 &lt;&lt; IPS_OFFLOAD_BIT),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    IPS_UNCHANGEABLE_MASK = (IPS_NAT_DONE_MASK | IPS_NAT_MASK |
</span></span><span class=line><span class=cl>                 IPS_EXPECTED | IPS_CONFIRMED | IPS_DYING |
</span></span><span class=line><span class=cl>                 IPS_SEQ_ADJUST | IPS_TEMPLATE | IPS_OFFLOAD),
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><a href=#36nf_conntrack_in进入连接跟踪><h2 id=36nf_conntrack_in进入连接跟踪><span class=hanchor arialabel=Anchor># </span>3.6 <code>nf_conntrack_in()</code>：进入连接跟踪</h2></a><p><img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668675210.png width=auto alt=upgit_20221117_1668675210.png></p><center>Fig. Netfilter 中的连接跟踪点</center><p>如上图所示，Netfilter 在四个 Hook 点对包进行跟踪：</p><ol><li><p><code>PRE_ROUTING</code> 和 <code>LOCAL_OUT</code>：<strong>调用 nf_conntrack_in() 开始连接跟踪</strong>， 正常情况下会创建一条新连接记录，然后将 conntrack entry 放到 <strong>unconfirmed list</strong>。</p><p>为什么是这两个 hook 点呢？因为它们都是<strong>新连接的第一个包最先达到的地方</strong>，</p><ul><li><code>PRE_ROUTING</code> 是<strong>外部主动和本机建连</strong>时包最先到达的地方</li><li><code>LOCAL_OUT</code> 是<strong>本机主动和外部建连</strong>时包最先到达的地方</li></ul></li><li><p><code>POST_ROUTING</code> 和 <code>LOCAL_IN</code>：<strong>调用 nf_conntrack_confirm() 将 nf_conntrack_in() 创建的连接移到 confirmed list</strong>。</p><p>同样要问，为什么在这两个 hook 点呢？因为如果新连接的第一个包没有被丢弃，那这 是它们<strong>离开 netfilter 之前的最后 hook 点</strong>：</p><ul><li><strong>外部主动和本机建连</strong>的包，如果在中间处理中没有被丢弃，<code>LOCAL_IN</code> 是其被送到应用（例如 nginx 服务）之前的最后 hook 点</li><li><strong>本机主动和外部建连</strong>的包，如果在中间处理中没有被丢弃，<code>POST_ROUTING</code> 是其离开主机时的最后 hook 点</li></ul></li></ol><p>下面的代码可以看到<strong>这些 handler 是如何注册到 Netfilter hook 点的</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_conntrack_proto.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* Connection tracking may drop packets, but never alters them, so make it the first hook.  */
</span></span><span class=line><span class=cl>static const struct nf_hook_ops ipv4_conntrack_ops[] = {
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        .hook        = ipv4_conntrack_in,       // 调用 nf_conntrack_in() 进入连接跟踪
</span></span><span class=line><span class=cl>        .pf          = NFPROTO_IPV4,
</span></span><span class=line><span class=cl>        .hooknum     = NF_INET_PRE_ROUTING,     // PRE_ROUTING hook 点
</span></span><span class=line><span class=cl>        .priority    = NF_IP_PRI_CONNTRACK,
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        .hook        = ipv4_conntrack_local,    // 调用 nf_conntrack_in() 进入连接跟踪
</span></span><span class=line><span class=cl>        .pf          = NFPROTO_IPV4,
</span></span><span class=line><span class=cl>        .hooknum     = NF_INET_LOCAL_OUT,       // LOCAL_OUT hook 点
</span></span><span class=line><span class=cl>        .priority    = NF_IP_PRI_CONNTRACK,
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        .hook        = ipv4_confirm,            // 调用 nf_conntrack_confirm()
</span></span><span class=line><span class=cl>        .pf          = NFPROTO_IPV4,
</span></span><span class=line><span class=cl>        .hooknum     = NF_INET_POST_ROUTING,    // POST_ROUTING hook 点
</span></span><span class=line><span class=cl>        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        .hook        = ipv4_confirm,            // 调用 nf_conntrack_confirm()
</span></span><span class=line><span class=cl>        .pf          = NFPROTO_IPV4,
</span></span><span class=line><span class=cl>        .hooknum     = NF_INET_LOCAL_IN,        // LOCAL_IN hook 点
</span></span><span class=line><span class=cl>        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p><code>nf_conntrack_in()</code> 是<strong>连接跟踪模块的核心</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_conntrack_core.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>unsigned int
</span></span><span class=line><span class=cl>nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum, struct sk_buff *skb)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  struct nf_conn *tmpl = nf_ct_get(skb, &amp;ctinfo); // 获取 skb 对应的 conntrack_info 和连接记录
</span></span><span class=line><span class=cl>  if (tmpl || ctinfo == IP_CT_UNTRACKED) {        // 如果记录存在，或者是不需要跟踪的类型
</span></span><span class=line><span class=cl>      if ((tmpl &amp;&amp; !nf_ct_is_template(tmpl)) || ctinfo == IP_CT_UNTRACKED) {
</span></span><span class=line><span class=cl>          NF_CT_STAT_INC_ATOMIC(net, ignore);     // 无需跟踪的类型，增加 ignore 计数
</span></span><span class=line><span class=cl>          return NF_ACCEPT;                       // 返回 NF_ACCEPT，继续后面的处理
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>      skb-&gt;_nfct = 0;                             // 不属于 ignore 类型，计数器置零，准备后续处理
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  struct nf_conntrack_l4proto *l4proto = __nf_ct_l4proto_find(...);    // 提取协议相关的 L4 头信息
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (l4proto-&gt;error != NULL) {                   // skb 的完整性和合法性验证
</span></span><span class=line><span class=cl>      if (l4proto-&gt;error(net, tmpl, skb, dataoff, pf, hooknum) &lt;= 0) {
</span></span><span class=line><span class=cl>          NF_CT_STAT_INC_ATOMIC(net, error);
</span></span><span class=line><span class=cl>          NF_CT_STAT_INC_ATOMIC(net, invalid);
</span></span><span class=line><span class=cl>          goto out;
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>repeat:
</span></span><span class=line><span class=cl>  // 开始连接跟踪：提取 tuple；创建新连接记录，或者更新已有连接的状态
</span></span><span class=line><span class=cl>  resolve_normal_ct(net, tmpl, skb, ... l4proto);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  l4proto-&gt;packet(ct, skb, dataoff, ctinfo); // 进行一些协议相关的处理，例如 UDP 会更新 timeout
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (ctinfo == IP_CT_ESTABLISHED_REPLY &amp;&amp; !test_and_set_bit(IPS_SEEN_REPLY_BIT, &amp;ct-&gt;status))
</span></span><span class=line><span class=cl>      nf_conntrack_event_cache(IPCT_REPLY, ct);
</span></span><span class=line><span class=cl>out:
</span></span><span class=line><span class=cl>  if (tmpl)
</span></span><span class=line><span class=cl>      nf_ct_put(tmpl); // 解除对连接记录 tmpl 的引用
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>大致流程：</p><ol><li>尝试获取这个 skb 对应的连接跟踪记录</li><li>判断是否需要对这个包做连接跟踪，如果不需要，更新 ignore 计数（<code>conntrack -S</code> 能看到这个计数）， 返回 <code>NF_ACCEPT</code>；如果需要，就<strong>初始化这个 skb 的引用计数</strong>。</li><li>从包的 L4 header 中提取信息，初始化协议相关的 <code>struct nf_conntrack_l4proto {}</code> 变量，其中包含了该协议的<strong>连接跟踪相关的回调方法</strong>。</li><li>调用该协议的 <code>error()</code> 方法检查包的完整性、校验和等信息。</li><li>调用 <code>resolve_normal_ct()</code> <strong>开始连接跟踪</strong>，它会创建新 tuple，新 conntrack entry，或者更新已有连接的状态。</li><li>调用该协议的 <code>packet()</code> 方法进行一些协议相关的处理，例如对于 UDP，如果 status bit 里面设置了 <code>IPS_SEEN_REPLY</code> 位，就会更新 timeout。timeout 大小和协 议相关，越小越越可以防止 DoS 攻击（DoS 的基本原理就是将机器的可用连接耗尽）</li></ol><a href=#37init_conntrack创建新连接记录><h2 id=37init_conntrack创建新连接记录><span class=hanchor arialabel=Anchor># </span>3.7 <code>init_conntrack()</code>：创建新连接记录</h2></a><p>如果连接不存在（flow 的第一个包），<code>resolve_normal_ct()</code> 会调用 <code>init_conntrack</code> ，后者进而会调用 <code>new()</code> 方法创建一个新的 conntrack entry。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/net/netfilter/nf_conntrack_core.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// Allocate a new conntrack
</span></span><span class=line><span class=cl>static noinline struct nf_conntrack_tuple_hash *
</span></span><span class=line><span class=cl>init_conntrack(struct net *net, struct nf_conn *tmpl,
</span></span><span class=line><span class=cl>           const struct nf_conntrack_tuple *tuple,
</span></span><span class=line><span class=cl>           const struct nf_conntrack_l4proto *l4proto,
</span></span><span class=line><span class=cl>           struct sk_buff *skb, unsigned int dataoff, u32 hash)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    struct nf_conn *ct;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 从 conntrack table 中分配一个 entry，如果哈希表满了，会在内核日志中打印
</span></span><span class=line><span class=cl>    // &#34;nf_conntrack: table full, dropping packet&#34; 信息，通过 `dmesg -T` 能看到
</span></span><span class=line><span class=cl>    ct = __nf_conntrack_alloc(net, zone, tuple, &amp;repl_tuple, GFP_ATOMIC, hash);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    l4proto-&gt;new(ct, skb, dataoff); // 协议相关的方法
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    local_bh_disable();             // 关闭软中断
</span></span><span class=line><span class=cl>    if (net-&gt;ct.expect_count) {
</span></span><span class=line><span class=cl>        exp = nf_ct_find_expectation(net, zone, tuple);
</span></span><span class=line><span class=cl>        if (exp) {
</span></span><span class=line><span class=cl>            /* Welcome, Mr. Bond.  We&#39;ve been expecting you... */
</span></span><span class=line><span class=cl>            __set_bit(IPS_EXPECTED_BIT, &amp;ct-&gt;status);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            /* exp-&gt;master safe, refcnt bumped in nf_ct_find_expectation */
</span></span><span class=line><span class=cl>            ct-&gt;master = exp-&gt;master;
</span></span><span class=line><span class=cl>            ct-&gt;mark = exp-&gt;master-&gt;mark;
</span></span><span class=line><span class=cl>            ct-&gt;secmark = exp-&gt;master-&gt;secmark;
</span></span><span class=line><span class=cl>            NF_CT_STAT_INC(net, expect_new);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* Now it is inserted into the unconfirmed list, bump refcount */
</span></span><span class=line><span class=cl>    // 至此这个新的 conntrack entry 已经被插入 unconfirmed list
</span></span><span class=line><span class=cl>    nf_conntrack_get(&amp;ct-&gt;ct_general);
</span></span><span class=line><span class=cl>    nf_ct_add_to_unconfirmed_list(ct);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    local_bh_enable();              // 重新打开软中断
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (exp) {
</span></span><span class=line><span class=cl>        if (exp-&gt;expectfn)
</span></span><span class=line><span class=cl>            exp-&gt;expectfn(ct, exp);
</span></span><span class=line><span class=cl>        nf_ct_expect_put(exp);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return &amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL];
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>每种协议需要实现自己的 <code>l4proto->new()</code> 方法，代码见：<code>net/netfilter/nf_conntrack_proto_*.c</code>。 例如 TCP 协议对应的 <code>new()</code> 方法是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_conntrack_proto_tcp.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* Called when a new connection for this protocol found. */
</span></span><span class=line><span class=cl>static bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb, unsigned int dataoff)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    if (new_state == TCP_CONNTRACK_SYN_SENT) {
</span></span><span class=line><span class=cl>        memset(&amp;ct-&gt;proto.tcp, 0, sizeof(ct-&gt;proto.tcp));
</span></span><span class=line><span class=cl>        /* SYN packet */
</span></span><span class=line><span class=cl>        ct-&gt;proto.tcp.seen[0].td_end = segment_seq_plus_len(ntohl(th-&gt;seq), skb-&gt;len, dataoff, th);
</span></span><span class=line><span class=cl>        ct-&gt;proto.tcp.seen[0].td_maxwin = ntohs(th-&gt;window);
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>如果当前包会影响后面包的状态判断，<code>init_conntrack()</code> 会设置 <code>struct nf_conn</code> 的 <code>master</code> 字段。面向连接的协议会用到这个特性，例如 TCP。</p><a href=#38nf_conntrack_confirm确认包没有被丢弃><h2 id=38nf_conntrack_confirm确认包没有被丢弃><span class=hanchor arialabel=Anchor># </span>3.8 <code>nf_conntrack_confirm()</code>：确认包没有被丢弃</h2></a><p><code>nf_conntrack_in()</code> 创建的新 conntrack entry 会插入到一个 <strong>未确认连接</strong>（ unconfirmed connection）列表。</p><p>如果这个包之后没有被丢弃，那它在经过 <code>POST_ROUTING</code> 时会被 <code>nf_conntrack_confirm()</code> 方法处理，原理我们在分析过了 3.6 节的开头分析过了。 <code>nf_conntrack_confirm()</code> 完成之后，状态就变为了 <code>IPS_CONFIRMED</code>，并且连接记录从 <strong>未确认列表</strong>移到<strong>正常</strong>的列表。</p><p>之所以把创建一个新 entry 的过程分为创建（new）和确认（confirm）两个阶段 ，是因为<strong>包在经过 nf_conntrack_in() 之后，到达 nf_conntrack_confirm() 之前 ，可能会被内核丢弃</strong>。这样会导致系统残留大量的半连接状态记录，在性能和安全性上都 是很大问题。分为两步之后，可以加快半连接状态 conntrack entry 的 GC。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/net/netfilter/nf_conntrack_core.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* Confirm a connection: returns NF_DROP if packet must be dropped. */
</span></span><span class=line><span class=cl>static inline int nf_conntrack_confirm(struct sk_buff *skb)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    struct nf_conn *ct = (struct nf_conn *)skb_nfct(skb);
</span></span><span class=line><span class=cl>    int ret = NF_ACCEPT;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (ct) {
</span></span><span class=line><span class=cl>        if (!nf_ct_is_confirmed(ct))
</span></span><span class=line><span class=cl>            ret = __nf_conntrack_confirm(skb);
</span></span><span class=line><span class=cl>        if (likely(ret == NF_ACCEPT))
</span></span><span class=line><span class=cl>            nf_ct_deliver_cached_events(ct);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return ret;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>confirm 逻辑，省略了各种错误处理逻辑：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_conntrack_core.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* Confirm a connection given skb; places it in hash table */
</span></span><span class=line><span class=cl>int
</span></span><span class=line><span class=cl>__nf_conntrack_confirm(struct sk_buff *skb)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    struct nf_conn *ct;
</span></span><span class=line><span class=cl>    ct = nf_ct_get(skb, &amp;ctinfo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    local_bh_disable();               // 关闭软中断
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    hash = *(unsigned long *)&amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].hnnode.pprev;
</span></span><span class=line><span class=cl>    reply_hash = hash_conntrack(net, &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ct-&gt;timeout += nfct_time_stamp;   // 更新连接超时时间，超时后会被 GC
</span></span><span class=line><span class=cl>    atomic_inc(&amp;ct-&gt;ct_general.use);  // 设置连接引用计数？
</span></span><span class=line><span class=cl>    ct-&gt;status |= IPS_CONFIRMED;      // 设置连接状态为 confirmed
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    __nf_conntrack_hash_insert(ct, hash, reply_hash);  // 插入到连接跟踪哈希表
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    local_bh_enable();                // 重新打开软中断
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    nf_conntrack_event_cache(master_ct(ct) ? IPCT_RELATED : IPCT_NEW, ct);
</span></span><span class=line><span class=cl>    return NF_ACCEPT;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>可以看到，<strong>连接跟踪的处理逻辑中需要频繁关闭和打开软中断</strong>，此外还有各种锁， 这是短连高并发场景下连接跟踪性能损耗的主要原因？。</p><a href=#4-netfilter-nat-实现><h1 id=4-netfilter-nat-实现><span class=hanchor arialabel=Anchor># </span>4 Netfilter NAT 实现</h1></a><p>NAT 是与连接跟踪独立的模块。</p><a href=#41-重要数据结构和函数><h2 id=41-重要数据结构和函数><span class=hanchor arialabel=Anchor># </span>4.1 重要数据结构和函数</h2></a><p><strong>重要数据结构：</strong></p><p>支持 NAT 的协议需要实现其中的方法：</p><ul><li><code>struct nf_nat_l3proto {}</code></li><li><code>struct nf_nat_l4proto {}</code></li></ul><p><strong>重要函数：</strong></p><ul><li><code>nf_nat_inet_fn()</code>：NAT 的核心函数，在<strong>除 NF_INET_FORWARD 之外的其他 hook 点都会被调用</strong>。</li></ul><a href=#42-nat-模块初始化><h2 id=42-nat-模块初始化><span class=hanchor arialabel=Anchor># </span>4.2 NAT 模块初始化</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_nat_core.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>static struct nf_nat_hook nat_hook = {
</span></span><span class=line><span class=cl>    .parse_nat_setup    = nfnetlink_parse_nat_setup,
</span></span><span class=line><span class=cl>    .decode_session        = __nf_nat_decode_session,
</span></span><span class=line><span class=cl>    .manip_pkt        = nf_nat_manip_pkt,
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>static int __init nf_nat_init(void)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    nf_nat_bysource = nf_ct_alloc_hashtable(&amp;nf_nat_htable_size, 0);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    nf_ct_helper_expectfn_register(&amp;follow_master_nat);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    RCU_INIT_POINTER(nf_nat_hook, &amp;nat_hook);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>MODULE_LICENSE(&#34;GPL&#34;);
</span></span><span class=line><span class=cl>module_init(nf_nat_init);
</span></span></code></pre></td></tr></table></div></div><a href=#43struct-nf_nat_l3proto-协议相关的-nat-方法集><h2 id=43struct-nf_nat_l3proto-协议相关的-nat-方法集><span class=hanchor arialabel=Anchor># </span>4.3 <code>struct nf_nat_l3proto {}</code>：协议相关的 NAT 方法集</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/net/netfilter/nf_nat_l3proto.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct nf_nat_l3proto {
</span></span><span class=line><span class=cl>    u8    l3proto; // 例如，AF_INET
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    u32     (*secure_port    )(const struct nf_conntrack_tuple *t, __be16);
</span></span><span class=line><span class=cl>    bool    (*manip_pkt      )(struct sk_buff *skb, ...);
</span></span><span class=line><span class=cl>    void    (*csum_update    )(struct sk_buff *skb, ...);
</span></span><span class=line><span class=cl>    void    (*csum_recalc    )(struct sk_buff *skb, u8 proto, ...);
</span></span><span class=line><span class=cl>    void    (*decode_session )(struct sk_buff *skb, ...);
</span></span><span class=line><span class=cl>    int     (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><a href=#44struct-nf_nat_l4proto-协议相关的-nat-方法集><h2 id=44struct-nf_nat_l4proto-协议相关的-nat-方法集><span class=hanchor arialabel=Anchor># </span>4.4 <code>struct nf_nat_l4proto {}</code>：协议相关的 NAT 方法集</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// include/net/netfilter/nf_nat_l4proto.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct nf_nat_l4proto {
</span></span><span class=line><span class=cl>    u8 l4proto; // Protocol number，例如 IPPROTO_UDP, IPPROTO_TCP
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 根据传入的 tuple 和 NAT 类型（SNAT/DNAT）修改包的 L3/L4 头
</span></span><span class=line><span class=cl>    bool (*manip_pkt)(struct sk_buff *skb, *l3proto, *tuple, maniptype);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 创建一个唯一的 tuple
</span></span><span class=line><span class=cl>    // 例如对于 UDP，会根据 src_ip, dst_ip, src_port 加一个随机数生成一个 16bit 的 dst_port
</span></span><span class=line><span class=cl>    void (*unique_tuple)(*l3proto, tuple, struct nf_nat_range2 *range, maniptype, struct nf_conn *ct);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // If the address range is exhausted the NAT modules will begin to drop packets.
</span></span><span class=line><span class=cl>    int (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p>各协议实现的方法，见：<code>net/netfilter/nf_nat_proto_*.c</code>。例如 TCP 的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_nat_proto_tcp.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const struct nf_nat_l4proto nf_nat_l4proto_tcp = {
</span></span><span class=line><span class=cl>    .l4proto        = IPPROTO_TCP,
</span></span><span class=line><span class=cl>    .manip_pkt        = tcp_manip_pkt,
</span></span><span class=line><span class=cl>    .in_range        = nf_nat_l4proto_in_range,
</span></span><span class=line><span class=cl>    .unique_tuple        = tcp_unique_tuple,
</span></span><span class=line><span class=cl>    .nlattr_to_range    = nf_nat_l4proto_nlattr_to_range,
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><a href=#45nf_nat_inet_fn进入-nat><h2 id=45nf_nat_inet_fn进入-nat><span class=hanchor arialabel=Anchor># </span>4.5 <code>nf_nat_inet_fn()</code>：进入 NAT</h2></a><p>NAT 的核心函数是 <code>nf_nat_inet_fn()</code>，它会在以下 hook 点被调用：</p><ul><li><code>NF_INET_PRE_ROUTING</code></li><li><code>NF_INET_POST_ROUTING</code></li><li><code>NF_INET_LOCAL_OUT</code></li><li><code>NF_INET_LOCAL_IN</code></li></ul><p>也就是除了 <code>NF_INET_FORWARD</code> 之外其他 hook 点都会被调用。</p><p><strong>在这些 hook 点的优先级</strong>：<strong>Conntrack > NAT > Packet Filtering</strong>。 <strong>连接跟踪的优先级高于 NAT</strong> 是因为 NAT 依赖连接跟踪的结果。
<img src=https://images.cherryfloris.eu.org/ryken/2022/11/upgit_20221117_1668675238.png width=auto alt=upgit_20221117_1668675238.png></p><center>Fig. NAT</center><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>unsigned int
</span></span><span class=line><span class=cl>nf_nat_inet_fn(void *priv, struct sk_buff *skb, const struct nf_hook_state *state)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    ct = nf_ct_get(skb, &amp;ctinfo);
</span></span><span class=line><span class=cl>    if (!ct)    // conntrack 不存在就做不了 NAT，直接返回，这也是我们为什么说 NAT 依赖 conntrack 的结果
</span></span><span class=line><span class=cl>        return NF_ACCEPT;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    nat = nfct_nat(ct);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    switch (ctinfo) {
</span></span><span class=line><span class=cl>    case IP_CT_RELATED:
</span></span><span class=line><span class=cl>    case IP_CT_RELATED_REPLY: /* Only ICMPs can be IP_CT_IS_REPLY.  Fallthrough */
</span></span><span class=line><span class=cl>    case IP_CT_NEW: /* Seen it before? This can happen for loopback, retrans, or local packets. */
</span></span><span class=line><span class=cl>        if (!nf_nat_initialized(ct, maniptype)) {
</span></span><span class=line><span class=cl>            struct nf_hook_entries *e = rcu_dereference(lpriv-&gt;entries); // 获取所有 NAT 规则
</span></span><span class=line><span class=cl>            if (!e)
</span></span><span class=line><span class=cl>                goto null_bind;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            for (i = 0; i &lt; e-&gt;num_hook_entries; i++) { // 依次执行 NAT 规则
</span></span><span class=line><span class=cl>                if (e-&gt;hooks[i].hook(e-&gt;hooks[i].priv, skb, state) != NF_ACCEPT )
</span></span><span class=line><span class=cl>                    return ret;                         // 任何规则返回非 NF_ACCEPT，就停止当前处理
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                if (nf_nat_initialized(ct, maniptype))
</span></span><span class=line><span class=cl>                    goto do_nat;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>null_bind:
</span></span><span class=line><span class=cl>            nf_nat_alloc_null_binding(ct, state-&gt;hook);
</span></span><span class=line><span class=cl>        } else { // Already setup manip
</span></span><span class=line><span class=cl>            if (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))
</span></span><span class=line><span class=cl>                goto oif_changed;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>    default: /* ESTABLISHED */
</span></span><span class=line><span class=cl>        if (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))
</span></span><span class=line><span class=cl>            goto oif_changed;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>do_nat:
</span></span><span class=line><span class=cl>    return nf_nat_packet(ct, ctinfo, state-&gt;hook, skb);
</span></span><span class=line><span class=cl>oif_changed:
</span></span><span class=line><span class=cl>    nf_ct_kill_acct(ct, ctinfo, skb);
</span></span><span class=line><span class=cl>    return NF_DROP;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>首先查询 conntrack 记录，如果不存在，就意味着无法跟踪这个连接，那就更不可能做 NAT 了，因此直接返回。</p><p>如果找到了 conntrack 记录，并且是 <code>IP_CT_RELATED</code>、<code>IP_CT_RELATED_REPLY</code> 或 <code>IP_CT_NEW</code> 状态，就去获取 NAT 规则。如果没有规则，直接返回 <code>NF_ACCEPT</code>，对包不 做任何改动；如果有规则，最后执行 <code>nf_nat_packet</code>，这个函数会进一步调用 <code>manip_pkt</code> 完成对包的修改，如果失败，包将被丢弃。</p><a href=#masquerade><h3 id=masquerade><span class=hanchor arialabel=Anchor># </span>Masquerade</h3></a><p>NAT 模块</p><ul><li>一般配置方式：<code>Change IP1 to IP2 if matching XXX</code>。</li><li>高级配置方式：<code>Change IP1 to dev1's IP if matching XXX</code>，这种方式称为 Masquerade。</li></ul><p>Masquerade 优缺点：</p><ul><li>优点：<strong>当设备（网卡）的 IP 地址发生变化时，NAT 规则无需做任何修改</strong>。</li><li>缺点：<strong>性能比第一种方式要差</strong>。</li></ul><a href=#46nf_nat_packet执行-nat><h2 id=46nf_nat_packet执行-nat><span class=hanchor arialabel=Anchor># </span>4.6 <code>nf_nat_packet()</code>：执行 NAT</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/netfilter/nf_nat_core.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* Do packet manipulations according to nf_nat_setup_info. */
</span></span><span class=line><span class=cl>unsigned int nf_nat_packet(struct nf_conn *ct, enum ip_conntrack_info ctinfo,
</span></span><span class=line><span class=cl>               unsigned int hooknum, struct sk_buff *skb)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    enum nf_nat_manip_type mtype = HOOK2MANIP(hooknum);
</span></span><span class=line><span class=cl>    enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
</span></span><span class=line><span class=cl>    unsigned int verdict = NF_ACCEPT;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    statusbit = (mtype == NF_NAT_MANIP_SRC? IPS_SRC_NAT : IPS_DST_NAT)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (dir == IP_CT_DIR_REPLY)     // Invert if this is reply dir
</span></span><span class=line><span class=cl>        statusbit ^= IPS_NAT_MASK;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (ct-&gt;status &amp; statusbit)     // Non-atomic: these bits don&#39;t change. */
</span></span><span class=line><span class=cl>        verdict = nf_nat_manip_pkt(skb, ct, mtype, dir);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return verdict;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static unsigned int nf_nat_manip_pkt(struct sk_buff *skb, struct nf_conn *ct,
</span></span><span class=line><span class=cl>                     enum nf_nat_manip_type mtype, enum ip_conntrack_dir dir)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    struct nf_conntrack_tuple target;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* We are aiming to look like inverse of other direction. */
</span></span><span class=line><span class=cl>    nf_ct_invert_tuplepr(&amp;target, &amp;ct-&gt;tuplehash.tuple);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    l3proto = __nf_nat_l3proto_find(target.src.l3num);
</span></span><span class=line><span class=cl>    l4proto = __nf_nat_l4proto_find(target.src.l3num, target.dst.protonum);
</span></span><span class=line><span class=cl>    if (!l3proto-&gt;manip_pkt(skb, 0, l4proto, &amp;target, mtype)) // 协议相关处理
</span></span><span class=line><span class=cl>        return NF_DROP;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return NF_ACCEPT;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#5-配置和监控><h1 id=5-配置和监控><span class=hanchor arialabel=Anchor># </span>5. 配置和监控</h1></a><a href=#51-查看加载卸载-nf_conntrack-模块><h2 id=51-查看加载卸载-nf_conntrack-模块><span class=hanchor arialabel=Anchor># </span>5.1 查看/加载/卸载 nf_conntrack 模块</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ modinfo nf_conntrack
</span></span><span class=line><span class=cl>filename:       /lib/modules/5.15.0-46-generic/kernel/net/netfilter/nf_conntrack.ko
</span></span><span class=line><span class=cl>license:        GPL
</span></span><span class=line><span class=cl>alias:          nf_conntrack-10
</span></span><span class=line><span class=cl>alias:          nf_conntrack-2
</span></span><span class=line><span class=cl>alias:          ip_conntrack
</span></span><span class=line><span class=cl>srcversion:     30B45E5822722ACEDE23A4B
</span></span><span class=line><span class=cl>depends:        nf_defrag_ipv6,libcrc32c,nf_defrag_ipv4
</span></span><span class=line><span class=cl>retpoline:      Y
</span></span><span class=line><span class=cl>intree:         Y
</span></span><span class=line><span class=cl>name:           nf_conntrack
</span></span><span class=line><span class=cl>vermagic:       5.15.0-46-generic SMP mod_unload modversions
</span></span><span class=line><span class=cl>sig_id:         PKCS#7
</span></span><span class=line><span class=cl>signer:         Build time autogenerated kernel key
</span></span><span class=line><span class=cl>sig_key:        17:6F:92:2F:58:6B:B2:28:13:DC:71:DC:5A:97:EE:BA:D8:4B:C7:DE
</span></span><span class=line><span class=cl>sig_hashalgo:   sha512
</span></span><span class=line><span class=cl>signature:      0B:32:AA:93:F4:31:52:9C:FE:0D:80:B4:F6:7C:30:63:4C:F6:03:AA:
</span></span><span class=line><span class=cl>                ...
</span></span><span class=line><span class=cl>                E9:1F:45:C6:77:C2:29:99:B4:3D:1A:D2
</span></span><span class=line><span class=cl>parm:           tstamp:Enable connection tracking flow timestamping. (bool)
</span></span><span class=line><span class=cl>parm:           acct:Enable connection tracking flow accounting. (bool)
</span></span><span class=line><span class=cl>parm:           nf_conntrack_helper:Enable automatic conntrack helper assignment (default 0) (bool)
</span></span><span class=line><span class=cl>parm:           expect_hashsize:uint
</span></span><span class=line><span class=cl>parm:           enable_hooks:Always enable conntrack hooks (bool)
</span></span></code></pre></td></tr></table></div></div><p>卸载：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ rmmod nf_conntrack_netlink nf_conntrack
</span></span></code></pre></td></tr></table></div></div><p>重新加载：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ modprobe nf_conntrack
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 加载时还可以指定额外的配置参数，例如：
</span></span><span class=line><span class=cl>$ modprobe nf_conntrack nf_conntrack_helper=1 expect_hashsize=131072
</span></span></code></pre></td></tr></table></div></div><a href=#52-sysctl-配置项><h2 id=52-sysctl-配置项><span class=hanchor arialabel=Anchor># </span>5.2 sysctl 配置项</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sysctl -a | grep nf_conntrack
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_acct = 0
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_buckets = 262144                 # hashsize = nf_conntrack_max/nf_conntrack_buckets
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_checksum = 1
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_count = 2148
</span></span><span class=line><span class=cl>... # DCCP options
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_events = 1
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_expect_max = 1024
</span></span><span class=line><span class=cl>... # IPv6 options
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_generic_timeout = 600
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_helper = 0
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_icmp_timeout = 30
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_log_invalid = 0
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_max = 1048576                    # conntrack table size
</span></span><span class=line><span class=cl>... # SCTP options
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_be_liberal = 0
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_loose = 1
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_max_retrans = 3
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_close = 10
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_established = 21600
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_timestamp = 0
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_udp_timeout = 30
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_udp_timeout_stream = 180
</span></span></code></pre></td></tr></table></div></div><a href=#53-监控><h2 id=53-监控><span class=hanchor arialabel=Anchor># </span>5.3 监控</h2></a><a href=#丢包监控><h3 id=丢包监控><span class=hanchor arialabel=Anchor># </span>丢包监控</h3></a><p><code>/proc/net/stat</code> 下面有一些关于 conntrack 的详细统计：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat /proc/net/stat/nf_conntrack
</span></span><span class=line><span class=cl>entries   searched found    new      invalid  ignore   delete   delete_list insert   insert_failed drop     early_drop icmp_error  expect_new expect_create expect_delete search_restart
</span></span><span class=line><span class=cl>000008e3  00000000 00000000 00000000 0000309d 001e72d4 00000000 00000000    00000000 00000000      00000000 00000000   000000ee    00000000   00000000      00000000       000368d7
</span></span><span class=line><span class=cl>000008e3  00000000 00000000 00000000 00007301 002b8e8c 00000000 00000000    00000000 00000000      00000000 00000000   00000170    00000000   00000000      00000000       00035794
</span></span><span class=line><span class=cl>000008e3  00000000 00000000 00000000 00001eea 001e6382 00000000 00000000    00000000 00000000      00000000 00000000   00000059    00000000   00000000      00000000       0003f166
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>此外，还可以用 <code>conntrack</code> 命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ conntrack -S
</span></span><span class=line><span class=cl>cpu=0   found=0 invalid=743150 ignore=238069 insert=0 insert_failed=0 drop=195603 early_drop=118583 error=16 search_restart=22391652
</span></span><span class=line><span class=cl>cpu=1   found=0 invalid=2004   ignore=402790 insert=0 insert_failed=0 drop=44371  early_drop=34890  error=0  search_restart=1225447
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><ul><li>ignore：不需要做连接跟踪的包（回忆前面，只有特定协议的包才会做连接跟踪）</li></ul><a href=#conntrack-table-使用量监控><h3 id=conntrack-table-使用量监控><span class=hanchor arialabel=Anchor># </span>conntrack table 使用量监控</h3></a><p>可以定期采集系统的 conntrack 使用量，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat /proc/sys/net/netfilter/nf_conntrack_count
</span></span><span class=line><span class=cl>257273
</span></span></code></pre></td></tr></table></div></div><p>并与最大值比较：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat /proc/sys/net/netfilter/nf_conntrack_max
</span></span><span class=line><span class=cl>262144
</span></span></code></pre></td></tr></table></div></div><a href=#6-常见问题><h1 id=6-常见问题><span class=hanchor arialabel=Anchor># </span>6. 常见问题</h1></a><a href=#61-连接太多导致-conntrack-table-被打爆><h2 id=61-连接太多导致-conntrack-table-被打爆><span class=hanchor arialabel=Anchor># </span>6.1 连接太多导致 conntrack table 被打爆</h2></a><a href=#现象><h3 id=现象><span class=hanchor arialabel=Anchor># </span>现象</h3></a><a href=#业务层应用层现象><h4 id=业务层应用层现象><span class=hanchor arialabel=Anchor># </span>业务层（应用层）现象</h4></a><ol><li><p>存在随机、偶发的<strong>新建连接</strong>超时（connect timeout）。</p><p>例如，如果业务用的是 Java，那对应的是 <code>jdbc4.CommunicationsException</code> communications link failure 之类的错误。</p></li><li><p><strong>已有连接</strong>正常。</p><p>也就是没有 read timeout 或 write timeout 之类的报错，报错都集中为 connect timeout。</p></li></ol><a href=#网络层现象><h4 id=网络层现象><span class=hanchor arialabel=Anchor># </span>网络层现象</h4></a><ol><li><p>抓包会看到三次握手的<strong>第一个 SYN 包被宿主机静默丢弃了</strong>。</p><p>需要注意的是，常规的网卡统计（<code>ifconfig</code>）和内核统计（<code>/proc/net/softnet_stat</code>） <strong>无法反映出这些丢包</strong>。</p></li><li><p><code>1s+</code> 之后出发 SYN 重传，或者还没重传连接就关闭了。</p><p><strong>第一个 SYN 的重传是 1s，这个是内核代码里写死的，不可配置</strong>（具体实现见 
<a href=https://arthurchiao.art/blog/conntrack-design-and-implementation-zh/#ch_8.1 rel=noopener>附录</a>）。</p><p>再考虑到其他一些耗时，第一次重传的实际间隔要大于 1s。 如果客户端设置的超时时间很小，例如 <code>1.05s</code>，那可能来不及重传连接就被关闭了，然后向上层报 connect timeout 错误。</p></li></ol><a href=#操作系统层现象><h4 id=操作系统层现象><span class=hanchor arialabel=Anchor># </span>操作系统层现象</h4></a><p>内核日志中有如下报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ demsg -T
</span></span><span class=line><span class=cl>[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet
</span></span><span class=line><span class=cl>[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet
</span></span><span class=line><span class=cl>[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>另外，<code>cat /proc/net/stat/nf_conntrack</code> 或 <code>conntrack -S</code> 能看到有 drop 统计。</p><a href=#确认-conntrack-table-被打爆><h3 id=确认-conntrack-table-被打爆><span class=hanchor arialabel=Anchor># </span>确认 conntrack table 被打爆</h3></a><p>遇到以上现象，基本就是 conntrack 表被打爆了。确认：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat /proc/sys/net/netfilter/nf_conntrack_count
</span></span><span class=line><span class=cl>257273
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat /proc/sys/net/netfilter/nf_conntrack_max
</span></span><span class=line><span class=cl>net.netfilter.nf_conntrack_max = 262144
</span></span></code></pre></td></tr></table></div></div><p>如果有 conntrack count 监控会看的更清楚，因为我们命令行查看时，高峰可能过了。</p><a href=#解决方式><h3 id=解决方式><span class=hanchor arialabel=Anchor># </span>解决方式</h3></a><p>优先级从高到低：</p><ol><li><p>调大 conntrack 表</p><p>运行时配置（经实际测试，<strong>不会对现有连接造成影响</strong>）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> $ sysctl -w net.netfilter.nf_conntrack_max=524288
</span></span><span class=line><span class=cl> $ sysctl -w net.netfilter.nf_conntrack_buckets=131072 # 推荐配置 hashsize=nf_conntrack_count/4
</span></span></code></pre></td></tr></table></div></div><p>持久化配置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> $ echo &#39;net.netfilter.nf_conntrack_max = 524288&#39; &gt;&gt; /etc/sysctl.conf
</span></span><span class=line><span class=cl> $ echo &#39;net.netfilter.nf_conntrack_buckets = 131072&#39; &gt;&gt; /etc/sysctl.conf
</span></span></code></pre></td></tr></table></div></div><p>影响：连接跟踪模块<strong>会多用一些内存</strong>。具体多用多少内存，可参考 
<a href=https://arthurchiao.art/blog/conntrack-design-and-implementation-zh/#ch_8.2 rel=noopener>附录</a>。</p></li><li><p>减小 GC 时间</p><p>还可以调小 conntrack 的 GC（也叫 timeout）时间，加快过期 entry 的回收。</p><p><code>nf_conntrack</code> 针对不同 TCP 状态（established、fin_wait、time_wait 等）的 entry 有不同的 GC 时间。</p><p>例如，<strong>默认的 established 状态的 GC 时间是 423000s（5 天）</strong>。设置成这么长的 <strong>可能原因</strong>是：TCP/IP 协议中允许 established 状态的连接无限期不发送任何东西（但仍然活着） [8]，协议的具体实现（Linux、BSD、Windows 等）会设置各自允许的最大 idle timeout。为防止 GC 掉这样长时间没流量但实际还活着的连接，就设置一个足够保守的 timeout 时间。[8] 中建议这个值不小于 2 小时 4 分钟（作为对比和参考， <strong>Cilium 自己实现的 CT 中，默认 established GC 是 6 小时</strong>）。 但也能看到一些厂商推荐比这个小得多的配置，例如 20 分钟。</p><p>如果对自己的网络环境和需求非常清楚，那可以将这个时间调到一个合理的、足够小的值； 如果不是非常确定的话，还是<strong>建议保守一些，例如设置 6 个小时</strong> —— 这已经比默认值 5 天小多了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> $ sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established = 21600
</span></span></code></pre></td></tr></table></div></div><p>持久化：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> $ echo &#39;net.netfilter.nf_conntrack_tcp_timeout_established = 21600&#39; &gt;&gt; /etc/sysctl.conf
</span></span></code></pre></td></tr></table></div></div><p>其他几个 timeout 值（尤其是 <code>nf_conntrack_tcp_timeout_time_wait</code>，默认 <code>120s</code>）也可以适当调小， 但还是那句话：<strong>如果不确定潜在后果，千万不要激进地调小</strong>。</p></li></ol><a href=#7-总结><h1 id=7-总结><span class=hanchor arialabel=Anchor># </span>7. 总结</h1></a><p>连接跟踪是一个非常基础且重要的网络模块，但只有在少数场景下才会引起普通开发者的注意。</p><p>例如，L4LB 短时高并发场景下，LB 节点每秒接受大量并发短连接，可能导致 conntrack table 被打爆。此时的现象是：</p><ul><li>客户端和 L4LB 建连失败，失败可能是随机的，也可能是集中在某些时间点。</li><li>客户端重试可能会成功，也可能会失败。</li><li>在 L4LB 节点抓包看，客户端过来的 TCP SYNC 包 L4LB 收到了，但没有回 ACK。即，包 被静默丢弃了（silently dropped）。</li></ul><p>此时的原因可能是 conntrack table 太小，也可能是 GC 不够及 时，甚至是 
<a href=https://github.com/cilium/cilium/pull/12729 rel=noopener>GC 有bug</a>。</p><a href=#8-附录><h1 id=8-附录><span class=hanchor arialabel=Anchor># </span>8. 附录</h1></a><a href=#81-第一个-syn-包的重传间隔计算linux-419118-实现><h2 id=81-第一个-syn-包的重传间隔计算linux-419118-实现><span class=hanchor arialabel=Anchor># </span>8.1 第一个 SYN 包的重传间隔计算（Linux 4.19.118 实现）</h2></a><p>调用路径：<code>tcp_connect() -> tcp_connect_init() -> tcp_timeout_init()</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// net/ipv4/tcp_output.c
</span></span><span class=line><span class=cl>/* Do all connect socket setups that can be done AF independent. */
</span></span><span class=line><span class=cl>static void tcp_connect_init(struct sock *sk)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    inet_csk(sk)-&gt;icsk_rto = tcp_timeout_init(sk);
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// include/net/tcp.h
</span></span><span class=line><span class=cl>static inline u32 tcp_timeout_init(struct sock *sk)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    // 获取 SYN-RTO：如果这个 socket 上没有 BPF 程序，或者有 BPF 程序但执行失败，都返回 -1
</span></span><span class=line><span class=cl>    // 除非用户自己编写 BPF 程序并 attach 到 cgroup/socket，否则这里都是没有 BPF 的，因此这里返回 -1
</span></span><span class=line><span class=cl>    timeout = tcp_call_bpf(sk, BPF_SOCK_OPS_TIMEOUT_INIT, 0, NULL);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (timeout &lt;= 0)                // timeout == -1，接下来使用默认值
</span></span><span class=line><span class=cl>        timeout = TCP_TIMEOUT_INIT;  // 宏定义，等于系统的 HZ 数，也就是 1 秒，见下面
</span></span><span class=line><span class=cl>    return timeout;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// include/net/tcp.h
</span></span><span class=line><span class=cl>#define TCP_RTO_MAX    ((unsigned)(120*HZ))
</span></span><span class=line><span class=cl>#define TCP_RTO_MIN    ((unsigned)(HZ/5))
</span></span><span class=line><span class=cl>#define TCP_TIMEOUT_MIN    (2U) /* Min timeout for TCP timers in jiffies */
</span></span><span class=line><span class=cl>#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))    /* RFC6298 2.1 initial RTO value    */
</span></span></code></pre></td></tr></table></div></div><a href=#82-根据-nf_conntrack_max-计算-conntrack-模块所需的内存><h2 id=82-根据-nf_conntrack_max-计算-conntrack-模块所需的内存><span class=hanchor arialabel=Anchor># </span>8.2 根据 nf_conntrack_max 计算 conntrack 模块所需的内存</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat /proc/slabinfo | head -n2; cat /proc/slabinfo | grep conntrack
</span></span><span class=line><span class=cl>slabinfo - version: 2.1
</span></span><span class=line><span class=cl># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;
</span></span><span class=line><span class=cl>nf_conntrack      512824 599505    320   51    4 : tunables    0    0    0 : slabdata  11755  11755      0
</span></span></code></pre></td></tr></table></div></div><p>其中的 <strong>objsize 表示这个内核对象</strong>（这里对应的是 <code>struct nf_conn</code>）的大小， 单位是<strong>字节</strong>，所以以上输出表明<strong>每个 conntrack entry 占用 320 字节的内存空间</strong>。</p><p>如果忽略内存碎片（内存分配单位为 slab），那<strong>不同 size 的 conntrack table 占用的内存</strong>如下：</p><ul><li><code>nf_conntrack_max=512K</code>: <code>512K * 320Byte = 160MB</code></li><li><code>nf_conntrack_max=1M</code>: <code>1M * 320Byte = 320MB</code></li></ul><p>更精确的计算，可以参考 [9]。</p><a href=#references><h1 id=references><span class=hanchor arialabel=Anchor># </span>References</h1></a><ol><li><a href=https://wiki.aalto.fi/download/attachments/69901948/netfilter-paper.pdf rel=noopener>Netfilter connection tracking and NAT implementation</a>. Proc. Seminar on Network Protocols in Operating Systems, Dept. Commun. and Networking, Aalto Univ. 2013.</li><li><a href=https://docs.cilium.io/en/v1.7/gettingstarted/kubeproxy-free/ rel=noopener>Cilium: Kubernetes without kube-proxy</a></li><li><a href=https://arthurchiao.art/blog/k8s-l4lb/ rel=noopener>L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP</a></li><li><a href=https://docs.docker.com/network/bridge/ rel=noopener>Docker bridge network mode</a></li><li><a href=https://en.wikipedia.org/wiki/Netfilter rel=noopener>Wikipedia: Netfilter</a></li><li><a href=https://blog.cloudflare.com/conntrack-tales-one-thousand-and-one-flows/ rel=noopener>Conntrack tales - one thousand and one flows</a></li><li><a href=https://www.redhat.com/en/blog/how-connection-tracking-open-vswitch-helps-openstack-performance rel=noopener>How connection tracking in Open vSwitch helps OpenStack performance</a></li><li><a href=https://tools.ietf.org/html/rfc5382#section-5 rel=noopener>NAT Behavioral Requirements for TCP</a>, RFC5382</li><li><a href=https://johnleach.co.uk/posts/2009/06/17/netfilter-conntrack-memory-usage/ rel=noopener>Netfilter Conntrack Memory Usage</a></li></ol></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>反向链接</h3><ul class=backlinks><li>未发现反向链接</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>内部链接关系图</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://www.ryken.cloud/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><hr><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=alittlejs/md5.min.js></script><div id=gitalk-container></div><script>var gitalk=new Gitalk({clientID:"d21f4afcd185c95004e0",clientSecret:"8f1f442abf93a76461783af21c544717da9fc7b3",repo:"obsidian-publish",owner:"renyunkang",admin:["renyunkang"],id:location.href,distractionFreeMode:!1});gitalk.render("gitalk-container")</script><center><script>var caution=!1,now,visits;function setCookie(e,t,n,s,o,a){var i=e+"="+escape(t)+(n?"; expires="+n.toGMTString():"")+(s?"; path="+s:"")+(o?"; domain="+o:"")+(a?"; secure":"");!caution||(e+"="+escape(t)).length<=4e3?document.cookie=i:confirm("Cookie exceeds 4KB and will be cut!")&&(document.cookie=i)}function getCookie(s){var e=s+"=",n,t=document.cookie.indexOf(e);return t==-1?null:(n=document.cookie.indexOf(";",t+e.length),n==-1&&(n=document.cookie.length),unescape(document.cookie.substring(t+e.length,n)))}function deleteCookie(e,t,n){getCookie(e)&&(document.cookie=e+"="+(t?"; path="+t:"")+(n?"; domain="+n:"")+"; expires=Thu, 01-Jan-70 00:00:01 GMT")}function fixDate(e){var n=new Date(0),t=n.getTime();t>0&&e.setTime(e.getTime()-t)}now=new Date,fixDate(now),now.setTime(now.getTime()+730*24*60*60*1e3),visits=getCookie("counter"),visits?visits=parseInt(visits)+1:visits=1,setCookie("counter",visits,now),document.write("<font size=2>👋访问量："+visits+"")</script></center></div></body></html>